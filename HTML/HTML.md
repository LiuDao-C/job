### ★★★前端性能优化

````js
前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化
// 页面的内容方面
通过文件合并、css雪碧图等方式来减少http请求数，避免过多的请求造成等待的情况
通过DNS缓存等机制来减少DNS的查询次数
通过设置缓存策略，对常用不变的资源进行缓存,持久化缓存
图片使用懒加载和合理的图片格式
使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载
<img data-src="https://avatars0.githubusercontent.com/u/22117876?s=460&u=7bd8f32788df6988833da6bd155c3cfbebc68006&v=4">
等页面可见时，再执行以下代码：
const img = document.querySelector('img')
img.src = img.dataset.src
通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度
// 服务器方面
使用CDN服务来提高用户请求资源时的响应速度
服务端启用Gzip、Deflate等方式对于传输的资源进行压缩，减小文件的体积
减小cookie的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的cookie
// CSS和javascript方面
把样式表放在页面的head标签中，减少页面首次渲染的时间
避免使用@import标签
//浏览器渲染
减少回流和重绘
将脚本放在底部，，使用好async和defer这两个属性，，避免脚本的加载和执行阻塞页面的渲染
使用事件委托
事件节流，减少操作
````



### ★cookie、sessionStorage和localStorage的区别

````js
SessionStorage、LocalStorage、cookie这三者都可以被用来浏览器端存储数据，而且都是字符串类型的键值对。区别在于前两者属于HTML5 WebStorage，创建它们的目的是为了便于客户端存储数据。而cookie是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）。cookie数据在同源（协议、主机、端口）的http请求中携带（即使不需要用到），会在浏览器和服务器之间来回传递
// 存储大小
cookie数据大小不能超过4k
SessionStorage、LocalStorage虽然也有存储大小的限制，但比cookie大得多。可以达到5M或更大
// 有效时间
localStorage存储持久数据，浏览器关闭后数据不会丢失，除非主动删除数据
sessionStorage存储的数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话
cookie存储的数据在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭
// 作用域
sessionStorage只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享。
localStorage在所有同源窗口中都是共享的
cookie在所有同源窗口中都是共享的

cookie、sessionStorage和localStorage都是浏览器端常用的存储技术
cookie其实最开始时服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie最多只能存储4k数据，它的生存时间由expires属性指定，并且cookie只能被同源的页面访问共享
sessionStorage是html5提供的一种浏览器本地存储的方法，它借鉴了服务器端session的概念，代表的是一次会话中所保存的数据。它一般能够存储5M甚至更大的数据，但它在当前窗口关闭后就失效了，并且sessionStorage只能被同一个窗口的同源页面所访问共享
localStorage也是html5提供的一种浏览器本地存储的方法，它一般也能够存储5M甚至更大的数据，它和sessionStorage不同的是，除非手动删除它，否则它不会失效，并且localStorage也只能被同源页面所访问共享
上面几种方式都是存储少量数据的时候的存储方式，当我们需要在本地存储大量数据的时候，我们可以使用浏览器的indexDB。这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近NoSQL数据库。
````



### ★async和defer的作用与区别

````js
<script src="script.js"></script>
1、脚本没有defer或async，浏览器会立即加载并执行指定的脚本，”立即“指的是在渲染该script标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到脚本就加载并执行。
<script defer src="myscript.js"></script>
2、defer属性表示延迟执行引入的javascript，即这段javascript加载时，HTML并未停止解析，这两个过程是并行的，但是脚本文件的执行要在所有元素解析完成之后，DOMContentLoaded事件触发之前完成。多个脚本按顺序执行。
3、async属性表示异步执行引入的javascript，与defer的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证，因为只要加载完了就会执行
````



### ★CSS如何阻塞文档解析

````js
理论上，既然样式表不改变DOM树，那就没有必要停下文档的解析等待它们，但是有一个问题，javascript脚本执行时可能会请求样式信息，如果此时样式还没有加载和解析，脚本将会得到错误的值，显然这将会导致很多问题。
所以如果浏览器尚未完成CSS规则的下载和构建时想要运行脚本，那么浏览器将延迟javascript脚本的执行和文档解析，直至完成CSSOM的下载和构建。也就是说在这种情况下，浏览器会先下载和构建CSSOM，然后再执行javascript。最后再继续文档的解析。
````



### ★HTML5新特性

````js
绘画canvas
用于媒介回放的video和audio元素
本地离线存储localStorage长期存储数据，浏览器关闭后数据不丢失
sessionStorage的数据在浏览器关闭后自动删除
语义化更好的内容元素，如article、footer、header、nav、section
表单控件，如calendar、date、time、email、url、search
新的技术webworker、websocket
新的文档属性document.visibilityState
````



### ★常用的块级元素和行内元素有哪些，它们的区别？

````js
常见的块级元素有 div ul ol li dl dt dd h1 p
常见的行内元素有 a b span img strong button input label select textarea
//区别
格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行
内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他元素。
行内元素与块级元素的属性不同，主要是盒模型属性上：行内元素设置width和height无效（可以设置inline—height），设置margin和padding的上下不会对其他元素产生影响。
````



### link和@import的区别

页面导入样式时，使用link和@import的区别

1. 从属关系区别。@import是CSS提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载CSS文件，还可以定义RSS、rel连接属性、引入网站图标等。
2. 加载顺序区别。加载页面时，link标签引入的CSS被同时加载；@import引入的CSS将在页面加载完完毕后被加载。
3. 兼容性区别。@import是CSS2.1才有的语法，故只可在IE5以上才能识别；link标签作为HTML元素，不存在兼容性问题。
4. DOM可控性区别。可以通过JS操作DOM，插入link标签来改变样式；由于DOM方法是基于文档的，所以无法使用@import的方式插入样式。

````js
<link rel="stylesheet" href="./test.css">
<style type="text/css">@import url("test.css");</style>
````



### 浏览器的渲染原理

1. 首先解析收到的文档，遍历文档节点，构建一棵DOM树，DOM树是由DOM元素及属性节点组成的。（display:none，注释，script标签都会在DOM树中）

2. 然后对CSS进行解析，生成CSSOM规则树。

3. 根据DOM树和CSSOM规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和DOM元素相对应，但这种对应关系不是一对一的，不可见的DOM元素不会被插入渲染树。还有一些DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。

4. 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做**回流**）。从根节点开始，计算每一个元素的大小、位置，给出每个节点所应该出现的屏幕精确坐标，从而得到基于渲染树的 **布局渲染树**。（脱离文档流，就是脱离render tree）

5. 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的paint方法将它们的内容显示在屏幕上，绘制使用UI绘制组件。

   值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。





### 渲染页面时常见问题

````js
//由于浏览器的渲染机制不同，有些会出现FOUC问题，有些会出现白屏问题
FOUC：主要指样式闪烁问题，由于浏览器渲染机制（如firefox），在CSS加载之前先呈现了HTML，就会导致展示出无样式内容，然后样式突然呈现的现象。出现这个问题的主要原因是CSS加载时间过长，或者CSS被放在了文档底部

白屏:有些浏览器渲染机制（如chrome和IE）要先构建DOM树和CSSOM树，构建完成后再进行渲染，如果CSS部分放在HTML底部，由于CSS未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把js文件放在头部，脚本的加载会阻塞后面文档内容的解析，从而导致页面迟迟未渲染出来，出现白屏问题。
````



### 什么是重绘和回流，如何减少

````js
重绘：当渲染树中的元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响页面布局，比如background-color，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的重新像素绘制，因此损耗较少。
回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新渲染页面，这样的操作会影响页面布局，我们称之为回流。

常见引起回流的属性和方法：
任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。
// 添加或者删除可见的DOM元素
// 元素尺寸改变——边距、填充、边框、宽度和高度
// 元素位置发生变化
// 内容变化，比如用户在input框中输入文字
// 浏览器窗口尺寸改变——resize事件发生时
// 计算offsetWidth和offsetHeight属性（这些属性和方法都需要返回最新的布局信息，因此浏览器不得不清空渲染队列，触发回流重绘来返回正确的值）
// 设置style属性的值
// 修改网页的默认字体
回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。

减少回流：
// 使用transform代替top
// 不要把节点的属性值放在一个循环里当成循环里的变量
// 不要使用table布局，因为一个很小的改动可能会造成整个table的重新布局
当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数：
使元素脱离文档流,对其进行多次修改,将元素带回到文档中。
有三种方式可以让DOM脱离文档流：
隐藏元素，应用修改，重新显示
使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。
将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。
// 不要逐条修改DOM的样式，可以预先定义好css的class，然后修改DOM的className

// 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘
// 对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。
// css3硬件加速的坑
// 如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。
// 在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。
常见的触发硬件加速的css属性：
transform
opacity
filters
Will-change
````



### 对HTML语义化的理解

````js
// 用正确的标签做正确的事情
// html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析
// 即使在没有样式css情况下也以一种文档格式显示，并且是容易阅读的
// 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO
// 使阅读源代码的人更容易将网站分块，便于阅读维护理解

我认为html语义化主要指的是我们应该使用合适的标签来划分网页内容的结构。html的本质作用其实就是定义网页文档的结构，一个语义化的文档能够使页面的结构更加清晰，易于理解。这样不仅有利于开发者的维护和理解，同时也能够使机器对文档内容进行正确的解读。比如说我们常用的b标签和strong标签，它们在样式上都是文字的加粗，但是strong标签拥有强调的语义。对于一般显示来说，可能我们看上去没有差异，但是对于机器来说，就会有很大的不同。如果用户使用的是屏幕阅读器来访问网页的话，使用strong标签就会有明显的语调上的变化，而b标签则没有。如果是搜索引擎的爬虫对我们网页进行分析的话，那么它会依赖于html标签来确定上下文和各个关键字的权重，一个语义化的文档对爬虫来说是友好的，是有利于爬虫对文档内容解读的，从而有利于我们网站的SEO。从html5我们可以看出，标准是倾向于以语义化的方式构建网页的，比如新增了header、footer这些语义化标签，删除了big、font这些没有语义的标签。
````



### 前端需要注意哪些SEO

````js
// 合理的title、description、keywords：搜索对这三项的权重逐个减小，title值强调重点即可，重要关键词不要出现超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description要有所不同，keywords列举出重要关键词即可
// 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页
// 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被抓取
// 重要内容不要用js输出：爬虫不会执行js获取内容
// 少用iframe：搜索引擎不会抓取iframe中的内容
// 非装饰性图片必须加alt
// 提高网站速度：网站速度是搜索引擎排序的一个重要指标
````



### iframe有哪些缺点

````js
iframe元素会创建包含另外一个文档的内联框架，即行内框架
缺点：
// iframe会阻塞主页面的onload事件。window的onload事件需要在所有iframe加载完毕后（包含里面的元素）才会触发。在Safari和chrome里，通过javascript动态设置iframe的src可以避免这种阻塞情况
// 搜索引擎的检索程序无法解读这种页面，不利于网页的SEO
// iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载
// 会使浏览器的后退按钮失效，
// 小型的移动设备无法完全显示框架
````



### 如何实现浏览器内多个标签页之间的通信

````js
// 使用websocket，让需要通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端
// 使用sharedworker（只在chrome浏览器实现了），两个页面共享同一个线程，通过向线程发送数据和接收数据来实现标签页之间的双向通信
// 可以调用localStorage、cookies等本地存储方式，localStorage在另一个浏览上下文中被添加、修改或删除时，它都会触发一个storage事件，我们通过监听storage事件，可以控制它的值来进行页面信息通信
// 如果我们能够获得对应标签页的引用，通过postMessage方法也是可以实现多个标签页通信的

实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。
第一种实现的方式是使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。
第二种是使用 ShareWorker 的方式，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。
第三种方式是使用 localStorage 的方式，我们可以在一个标签页内对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。
还有一种方式是使用 postMessage 方法，如果我们能够获得对应标签页的引用，我们就可以使用 postMessage 方法进行通信。
````



### 页面可见性有哪些用途

````js
页面可见性（Page Visibility API）这个新的API的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户不看网页，下面这些网页行为都是可以暂停的。
// 对服务器的轮询
// 网页动画
// 正在播放的音频或视频
````



### 如何在页面上实现一个圆形的可点击区域

````js
// 纯html实现，使用<area>来给<img>图像标记热点区域的方式，<map>标签用来定义一个客户端图像映射，<area>标签用来定义图像映射中的区域，area元素永远嵌套在map元素内部，我们可以将 area区域设置为圆形，从而实现可点击的圆形区域。
// 纯css实现，使用border-radius，当border-radius的长度等于宽高相等的元素值的一半时，即可实现一个圆形的点击区域。
// 纯js实现，判断一个点在不在圆上的简单算法，通过监听文档的点击事件，获取每次点击时鼠标的位置，判断该位置是否在我们规定的圆形区域内。
````



### canvas和SVG有什么区别

````js
canvas是通过javascript来绘制2D图形的方法，它是逐像素来进行渲染的，因此在对canvas进行缩放时，会出现锯齿或者失真的情况
SVG是一种使用XML描述2D图形的语言。SVG基于XML,这意味着SVG DOM中的每个元素都是可用的。我们可以为某个元素附加javascript事件监听函数，并且SVG保存的是图形的绘制方法。因此当SVG图形缩放时并不会失真
````



### 大量DOM操作

````js
减少 DOM 操作次数的良方是 DocumentFragment；
缩短循环时间需要考虑使用分治的思想把 30000 个 <li> 分批次插入到页面中，每次插入的时机是在页面重新渲染之前，采用 requestAnimationFrame 。
window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行
````





